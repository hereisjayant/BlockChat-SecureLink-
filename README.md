# SecureLink

SecureLink is a decentralized messaging web app that uses blockchain technology to securely deliver encrypted messages between users. By leveraging the Signal Protocol, SecureLink offers message confidentiality and integrity through encryption.

The increasing reliance on the internet for communication has brought attention to internet censorship and privacy concerns. Governments in countries such as China, Saudi Arabia, and Turkey have implemented censorship policies to suppress public dissent among their citizens. In addition, some governments have blocked open-source end-to-end encrypted messaging apps, such as Signal, in order to prevent citizens from communicating and organizing protests.

SecureLink aims to provide a decentralized solution for online communication that supports message confidentiality and integrity via encryption. By using blockchain technology to send and receive messages, SecureLink offers a secure method for online communication that does not rely on a centralized server.

## System Design Summary
The project can be split into four major components: the implementation of the blockchain network, smart contracts, message encryption, and local storage. The blockchain network acts as a distributed data structure that stores messages in encrypted form. Using blockchain technology helps ensure message integrity and authenticity. Smart contracts act as the delivery mechanism on the blockchain that allows users to send and fetch messages from the blockchain. To ensure confidentiality, the messages are encrypted using the Signal protocol, which utilizes the Double Ratchet algorithm to generate new keys for each message while also allowing messages to be received out of order. Finally, the application will securely store the sent and received messages in an encrypted local database. Storing the messages on the user’s system allows for messages to be reviewed offline, and encrypting the messages ensures that malicious actors will have a hard time reading the messages even if they have access to the user’s system

![Figure 1: Diagram of Overall System Design](https://user-images.githubusercontent.com/35059479/209487496-2cfb9d60-6fea-489b-984c-080f7e01676e.png "Figure 1: Diagram of Overall System Design")

### Blockchain Network
The blockchain is an implementation of a decentralized, digital ledger of transactions. Anything that can be recorded digitally can be stored on the blockchain and anyone with an adequate machine can access and contribute to it. This way, the use of a blockchain offers both transparency and accessibility of its data.

The immutability of data is another key feature offered by blockchains. Data in the blockchain is stored in blocks, where each block contains a list of validated transactions and other essential metadata. Additionally, each block must have a way to link to its previous block, such that multiple blocks will form a linked “chain”. By taking advantage of a number of cryptographic principles, participants cannot change/tamper with data blocks that have already been recorded on the blockchain because they will “break” the links between blocks.

Decentralization is realized by relying on a network of nodes to each store a copy of the blockchain. Instead of depending on a central authority to manage a single source of truth, the blockchain relies on massive data replication to maintain data quality. Additionally, specialized nodes called validators are typically held responsible for participating in the validation of new data blocks. In this process, nodes need to agree on a set of rules, called a consensus mechanism. Nodes will use the consensus mechanism to verify new transactions and decide on the current state of the blockchain in the event of a conflict.

Beside the benefits of decentralization and immutability, a blockchain can be used to verify the transfer of digital assets (transactions) without the use of middlemen. However, because any mutative interaction with the blockchain requires some amount of work from both nodes and miners, some amount of payment is required in exchange for publishing new data (blocks/transactions) to the blockchain.

The usage of the blockchain was decided largely because of the properties it offers in terms of immutability and decentralization. By relying on a decentralized ledger, a central authority should have a hard time censoring communication between participants or preventing them altogether.

#### Ethereum
Currently, there are a number of blockchain networks that have been widely adopted like Ethereum and Bitcoin. The choice to rely on the Ethereum network is grounded on its popularity as a time-tested tool and its ability to offer smart contract functionality. 
#### Cryptocurrency Wallets
In order to conduct transactions on the blockchain, participants require some type of “identifier” that can be used to identify them as a sender/receiver in a transaction. The blockchain relies on public key cryptography, where participants are associated with a public key and a private key. The private key is used to sign transactions as the authorized user, while the public key is used to identify the participant. A “wallet” can be used to securely store the private key, while the public key can be included in transaction blocks or shared across the network without concern. Thus, the security of a person’s message and identity will also depend on the security of the user’s crypto wallet. 
In theory, a wallet’s public address cannot be traced back to the true identity of its user(s) - an exception to this is when the original user purposely or carelessly associates their wallet’s public key to their own identity. An example of this is  by obtaining a wallet from an identifiable cryptocurrency exchange.

### Smart Contracts
The system’s messaging logic is governed largely by smart contracts that are written on top of the Ethereum blockchain. The smart contracts are written in Solidity, a high-level programming language specifically created for the development of smart contracts on a number of blockchain networks. Conveniently, Solidity features functionality that supports modular design and data type validation.
In the system, the smart contract automatically validates and executes the logic behind sending and receiving messages. Because interactions with the blockchain require some form of payment to compensate for the computational power consumed, the smart contract is also responsible for managing the fees for each transaction. Figure 2 shows a general breakdown of the functions of the smart contract and how it interacts with the blockchain, the sender/recipient, and other participating services in the system.

![image7](https://user-images.githubusercontent.com/35059479/209487774-0cf84ea9-74b9-4e56-8683-5f1fcd1030ac.png)


During every interaction with the smart contract, it will typically check for the identity of the user by accepting the public key of a cryptocurrency wallet. At the beginning, a newly-opened application will typically want to get all the existing messages related to a certain other participant (the recipient). By sending the public address of the desired recipient, the smart contract will simply fetch all the existing messages from the blockchain and return it to the client (the sender).
In the case that a client wants to start sending messages, the smart contract will first check that the wallet associated with the sender has sufficient funds to send the transaction. Following this, it will wait for the transaction to be added to a block and validated. Once a message has been pushed onto the blockchain, it will emit an event that the recipient can listen for. As illustrated in figure 2, the smart contract does not handle message encryption/decryption and, since the blockchain will only store messages in encrypted form, will only ever manage data that have already been encrypted.

### Signal Protocol
The system provides secure messaging by using the Signal Protocol - more specifically, the system uses the Double Ratchet algorithm to provide message confidentiality and integrity. The Double Ratchet protocol makes use of key derivation functions which take keys and an application specific input to produce different keys. The main goal of this algorithm is to be able to use unique message keys for each message and to allow parties to communicate without having to exchange the needed decryption keys beforehand. To begin, both communicating parties will have a shared key called the Root Key. This Root Key (labeled “RK” in Figure 3), will be used to generate sending (encryption) and receiving (decryption) keys using a key derivation function. The output of the key derivation function will be two keys - one key will be used for sending/receiving and another will be used as input to generate the next message key if the user wants to send the message. This process is illustrated in the “Root”, “Sending”, and “Receiving” columns in Figure 3, where the gray boxes represent the use of a key derivation function and the lines display show how the output of previous key derivation functions will be used as input for another key derivation function. The “RK” blocks in Figure 3 represent the Root Key, “CK” blocks represents Chain Keys that are used to generate sending/receiving keys, and “A#” and “B#” blocks represent message keys. The two communicating parties should have reversed chains, as in the sending chain of one party will be the receiving chain of the other party. This whole process gets reset every full message exchange where Diffie-Hellman (DH) public key values are exchanged to generate new keys. This is demonstrated in the “Ratchet” and “Root” Figure 3 columns where the public Diffie-Hellman key values are in cyan and the private values are in yellow.

![image2](https://user-images.githubusercontent.com/35059479/209487823-1b121d6d-f7fd-4e07-9f98-9fd7ab6c3f7d.png)

Messages are encrypted using AES-256 in CBC cipher mode and an HMAC will be used to provide integrity. Using this algorithm also allows for messages to be received out of order since the algorithm will store previous message keys, and the only public information about the keys will be the public Diffie-Hellman key values used to help generate the Root Key. 

Following this algorithm for message encryption and decryption applies the principle of open design. We are using a public algorithm that has existed for years and is widely used by other messaging applications such as Signal and Whatsapp who tout end-to-end encryption and security. Additionally, the algorithm applies the principle of time tested tools, as it utilizes well-tested and well-known cryptographic primitives for hashing, encryption, and key derivation. The algorithm also provides perfect forward secrecy as each message is encrypted with a separate encryption key. In the event that an attacker manages to learn one of the Root Keys, or one of the sending/receiving key keychains, the two communicating parties will continuously ‘reset’ their ratchets using the DH key exchange. Finally, this design applies the principle of sufficient work factor, as an attacker would need to compute a unique key and IV for every message sent that was encrypted using AES-256. The effort needed to decrypt an entire conversation between two parties by brute force is currently impossible relative to the length of a human lifetime.

### Local Storage
The messages a user sends and receives will be stored locally in an encrypted database. By storing the messages locally, it gives users the ability to read messages offline, and the application can show past messages to the user more efficiently. Similarly, Signal stores messages locally on the user’s device. Since the application will manage the stored database, it reduces the need for other security measures like a password that would create more work for the user. The application will need the user’s cryptocurrency wallet to begin with, and the user’s system will already be locked by their system password or biometrics like Windows Hello.
Since we emulate Signal’s methodology for message storage, we can consider the solution on par with other security focused applications. This design follows the security principle of open design as we rely on the same public methodology other applications apply. Additionally, it applies the principle of time tested tools as we can use an open source encrypted database such as SQLCipher instead of creating the own encrypted database to implement this functionality. 

## System Prototype
We evaluated the system design by developing a prototype web application using React and NodeJS. We also utilized Metamask and Ganache to test the functionality of the smart contract on a local blockchain. Metamask is a popular browser addon that allows users to create a cryptocurrency hot wallet. Ganache is a downloadable application that can create a local Ethereum-based blockchain. The system used React to create the front-end of the application and NodeJS to write the message encryption protocols. 

### Web Application
In the system, we wanted to utilize available open-source frameworks such as the web3 Javascript library which had been built to assist the development of applications that needed to interact with the Ethereum blockchain. React was the library chosen for creating the user interface because it offers a lightweight and efficient solution that can take advantage of the existing web3 library. 
The first time a user opens the application, the user will have to create a password that will be used to authenticate the user for future uses and used to encrypt the plaintext messages the user sends and receives that will be stored locally. The password is hashed with PBKDF2 using SHA-256 and 310,000 iterations following the recommendations of the Open Web Application Security Project (OWASP) and uses a randomly generated salt. To generate the encryption and authentication key, it uses PBKDF2 using SHA-512, 120,000 iterations, and a random salt as recommended by OWASP to generate two 32 byte keys. The messages are encrypted using AES-256 in CBC ciphermode with a randomly generated IV, and the integrity of the messages is assured by using a HMAC that takes the ciphertext, IV, the random salt used to generate the keys concatenated together as input and hashed with the aforementioned generated authentication key from the password. 
We used a password instead of an encrypted database since it was easier to prototype, but adding the password does make the application harder to use. The password puts additional work onto the user, and the application already has two barriers in place that block access to the application. One barrier is the password or biometric implementation required to login to the system and the other is the user’s authentication for accessing Metamask, their digital wallet. 
Next, the user will be able to select the address of the person they want to talk to on the sidebar. All the public addresses of nodes on the blockchain are visible in this sidebar. On an actual blockchain network with potentially thousands or millions of users, this method of selecting public addresses would be inefficient and user-unfriendly. However, using the local blockchain allows us to specify a small number of auto-generated public addresses which eases the process of testing the application. 
Once the user has selected a recipient’s public address, they are prompted by an interface similar to most other messaging applications. The interface will display messages previously exchanged between both parties as well as provide an input box for the user to type and send new messages. We designed this part of the application so it would closely mirror other messaging applications so users would have an easier time learning how to use the application. 
Once the user closes the web application and tries to open the application again, the user will be prompted for their password.

### Crypto API
The encryption algorithms were implemented using the Crypto library available from NodeJS. We predominantly used the Subtle module in Crypto, which provides an implementation of the Web Crypto API as recommended by the W3C. Alongside the client application, we had to create a backend server that would port out of localhost to handle all the necessary cryptographic computations. We could not get a client side cryptography library working, so this was the alternative we used instead. This should still be safe as the API calls should only be exposed if someone has access to the user’s system since the server ports out of localhost not a public IP address. 

### Local Blockchain
We used an open-source application, Ganache, to create a local blockchain for testing. Additionally, we used Metamask, a browser add-on which gives users access to a cryptocurrency hot wallet that is used for authentication and storing wallet data. In order to test both of them in unison, we needed to initialize test wallets on the local Ganache blockchain and imported them into Metamask for further use.



## Related Work
There has been much discussion about the benefits and drawbacks of a blockchain-based messaging system, but there have not been any large-scale implementations of such a system to date. Existing messaging apps that provide end-to-end encryption rely on the integrity of a third party to deliver messages, which can compromise security and privacy. On the other hand, decentralized messaging apps offer greater security and privacy, but can be less accessible and prone to network issues.

## Evaluation Summary
We evaluated BlockChat's usability and security through multiple trials of essential tasks to assess learnability, speed, efficiency, and user preference. The results were largely positive, with the UI design similar to existing messaging apps. In terms of security, we found that while BlockChat is resilient to simpler attacks such as 51% and port blocking, it is not able to fully deal with DPI (Deep Packet Inspection) attacks due to the power of a government-controlled ISP.

## Conclusion
While BlockChat offers secure and private communication through the use of blockchain technology and the Signal Protocol, it may not be the best choice for an individual's main secure messaging app due to the decentralization and costs associated with sending messages. However, it is a useful tool for those seeking to bypass censorship and maintain privacy in their online communication.
